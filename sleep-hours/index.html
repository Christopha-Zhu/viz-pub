<!DOCTYPE html>
<head>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<style>

body {
  font: 1em 'Lato', sans-serif;
}

text {
  font-family: Lato;
}

</style>

<link href="https://fonts.googleapis.com/css?family=Lato|Playfair+Display" rel="stylesheet">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css">

</head>
<body>
<div class="container">
  <div class="row">
    <div class="col">
      <h1>Cycle of sleep</h1>
      <p>Testing testing</p>
      <svg id="mainimg" width=600 height=600></svg>
      <p>Testing testing</p>
    </div>
  </div>
</div>








<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script>

function xpos(time, radius = 1) {
  return radius * Math.sin(2 * Math.PI * time/24);
}

function ypos(time, radius = 1) {
  return -radius * Math.cos(2 * Math.PI * time/24); 
}

var scale_color = d3.scaleLinear()
  .range([0.3, 1])
  .domain([0, 3]); // percent

var scale_timewidth = d3.scaleLinear()
  .range([0.000, 0.2])
  .domain([0, 3]); // percent

var svg = d3.select("#mainimg")
    .attr("viewBox", "-1.2, -1.2, 2.4, 2.4")
    .append("g");



d3.csv("data.csv", function(error, indata) {
  if (error) throw error;

  var data = [];
  d3.nest()
    .key(function(d) { return d.start; })
    .key(function(d) { return d.end; })
    .rollup(function(d) {
      return d3.sum(d, function(g) { return true ? +g.n : 0; })
    })
    .entries(indata)
    .forEach(function(d1) {
      d1.values.forEach(function(d2) {
        data.push({
          start: +d1.key,
          end: +d2.key,
          n: d2.value
        });
      });
    });

  var total = d3.sum(data, function(d2) { return d2.n; }) / 100;
  data.forEach(function(d) {
    d.interval = d.end - d.start + (d.end > d.start ? 0 : 24);
    d.midpoint = (d.start + d.interval / 2) % 24;
    d.n = d.n / total;
    
  });

  data.sort(function(x, y) {
    return d3.ascending(x.n, y.n);
  })


  
  svg.append("g").selectAll("path")
    .data([...Array(48).keys()])
    .enter()
    .append("path")
      .attr("d", function(d) { return "M 0 0" +
                                      " L " + xpos(d/2 + 0.25, 1.18) + " " + ypos(d/2 + 0.25, 1.18) +
                                      " L " + xpos(d/2 - 0.25, 1.18) + " " + ypos(d/2 - 0.25, 1.18) +
                                      " Z"; })
      .attr("fill", "#fff")
      .on("mouseover", function(d) {
        svg.selectAll(".timeline")
          .attr("opacity", function(dpath) { return dpath.start == d/2 || dpath.end == d/2 ? 1 : 0; });
      })
      .on("mouseout", function() {
        svg.selectAll(".timeline")
          .attr("opacity", 1);
      });

  svg.append("g").selectAll("text")
    .data([...Array(24).keys()])
    .enter()
    .filter(function(d) { return Math.round(d) == d; })
    .append("text")
      .text(function(d) { return d; })
      .attr("x", function(d) { return xpos(d, 1.07); })
      .attr("y", function(d) { return ypos(d, 1.07); })
      .attr("text-anchor", "middle")
      .attr("dominant-baseline", "middle")
      .style("pointer-events", "none")
      .attr("font-size", 0.05);
  

  svg.append("g").selectAll("path")
    .data(data)
    .enter()
    .filter(function(d) {return d.n > 0.01; })
    .append("path")
      .classed("timeline", true)
      .attr("d", function(d) { return "M " + xpos(d.start - scale_timewidth(d.n)/2) + " "  + ypos(d.start - scale_timewidth(d.n)/2) + " " +
                                      "Q " + xpos(d.midpoint, 0) + " " + ypos(d.midpoint, 0) + " " +
                                             xpos(d.end + scale_timewidth(d.n)/2) + " " + ypos(d.end + scale_timewidth(d.n)/2) + " " +
                                      "L " + xpos(d.end - scale_timewidth(d.n)/2) + " " + ypos(d.end - scale_timewidth(d.n)/2) + " " +
                                      "Q " + xpos(d.midpoint, scale_timewidth(d.n)/3.5) + " " + ypos(d.midpoint, scale_timewidth(d.n)/3.5) + " " +
                                             xpos(d.start + scale_timewidth(d.n)/2) + " "  + ypos(d.start + scale_timewidth(d.n)/2) +
                                      "Z"; })
      .attr("stroke", "#fff")
      .attr("fill", function(d) { return d3.interpolateYlGnBu(scale_color(d.n)); } )
      .attr("stroke-width", 0.0018)
      .style("pointer-events", "none");






  
});


</script>
</body>
</html>